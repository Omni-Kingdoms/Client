schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type T_Arena {
  id: ID!
  name: String!
  uri: String!
  cost: Int!
  cooldown: Int!
  host: T_Player
  arenaResult(skip: Int = 0, first: Int = 100, orderBy: T_ArenaResults_orderBy, orderDirection: T_OrderDirection, where: T_ArenaResults_filter): [T_ArenaResults!]!
}

type T_ArenaResults {
  id: ID!
  player: T_Player!
  arena: T_Arena!
  wins: Int!
  losses: Int!
}

input T_ArenaResults_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  player: String
  player_not: String
  player_gt: String
  player_lt: String
  player_gte: String
  player_lte: String
  player_in: [String!]
  player_not_in: [String!]
  player_contains: String
  player_contains_nocase: String
  player_not_contains: String
  player_not_contains_nocase: String
  player_starts_with: String
  player_starts_with_nocase: String
  player_not_starts_with: String
  player_not_starts_with_nocase: String
  player_ends_with: String
  player_ends_with_nocase: String
  player_not_ends_with: String
  player_not_ends_with_nocase: String
  player_: T_Player_filter
  arena: String
  arena_not: String
  arena_gt: String
  arena_lt: String
  arena_gte: String
  arena_lte: String
  arena_in: [String!]
  arena_not_in: [String!]
  arena_contains: String
  arena_contains_nocase: String
  arena_not_contains: String
  arena_not_contains_nocase: String
  arena_starts_with: String
  arena_starts_with_nocase: String
  arena_not_starts_with: String
  arena_not_starts_with_nocase: String
  arena_ends_with: String
  arena_ends_with_nocase: String
  arena_not_ends_with: String
  arena_not_ends_with_nocase: String
  arena_: T_Arena_filter
  wins: Int
  wins_not: Int
  wins_gt: Int
  wins_lt: Int
  wins_gte: Int
  wins_lte: Int
  wins_in: [Int!]
  wins_not_in: [Int!]
  losses: Int
  losses_not: Int
  losses_gt: Int
  losses_lt: Int
  losses_gte: Int
  losses_lte: Int
  losses_in: [Int!]
  losses_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_ArenaResults_filter]
  or: [T_ArenaResults_filter]
}

enum T_ArenaResults_orderBy {
  id
  player
  player__id
  player__Player_id
  player__name
  player__classes
  player__stats
  player__exp
  player__level
  player__strength
  player__magic
  player__agility
  player__defense
  player__currentHealth
  player__maxHealth
  player__currentMana
  player__maxMana
  player__totalWins
  player__totalLosses
  arena
  arena__id
  arena__name
  arena__uri
  arena__cost
  arena__cooldown
  wins
  losses
}

input T_Arena_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  cost: Int
  cost_not: Int
  cost_gt: Int
  cost_lt: Int
  cost_gte: Int
  cost_lte: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  cooldown: Int
  cooldown_not: Int
  cooldown_gt: Int
  cooldown_lt: Int
  cooldown_gte: Int
  cooldown_lte: Int
  cooldown_in: [Int!]
  cooldown_not_in: [Int!]
  host: String
  host_not: String
  host_gt: String
  host_lt: String
  host_gte: String
  host_lte: String
  host_in: [String!]
  host_not_in: [String!]
  host_contains: String
  host_contains_nocase: String
  host_not_contains: String
  host_not_contains_nocase: String
  host_starts_with: String
  host_starts_with_nocase: String
  host_not_starts_with: String
  host_not_starts_with_nocase: String
  host_ends_with: String
  host_ends_with_nocase: String
  host_not_ends_with: String
  host_not_ends_with_nocase: String
  host_: T_Player_filter
  arenaResult_: T_ArenaResults_filter
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_Arena_filter]
  or: [T_Arena_filter]
}

enum T_Arena_orderBy {
  id
  name
  uri
  cost
  cooldown
  host
  host__id
  host__Player_id
  host__name
  host__classes
  host__stats
  host__exp
  host__level
  host__strength
  host__magic
  host__agility
  host__defense
  host__currentHealth
  host__maxHealth
  host__currentMana
  host__maxMana
  host__totalWins
  host__totalLosses
  arenaResult
}

type T_BasicCraft {
  id: ID!
  slot: String!
  value: Int!
  cost: Int!
  oldName: String!
  newName: String!
  uri: String!
}

input T_BasicCraft_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  slot: String
  slot_not: String
  slot_gt: String
  slot_lt: String
  slot_gte: String
  slot_lte: String
  slot_in: [String!]
  slot_not_in: [String!]
  slot_contains: String
  slot_contains_nocase: String
  slot_not_contains: String
  slot_not_contains_nocase: String
  slot_starts_with: String
  slot_starts_with_nocase: String
  slot_not_starts_with: String
  slot_not_starts_with_nocase: String
  slot_ends_with: String
  slot_ends_with_nocase: String
  slot_not_ends_with: String
  slot_not_ends_with_nocase: String
  value: Int
  value_not: Int
  value_gt: Int
  value_lt: Int
  value_gte: Int
  value_lte: Int
  value_in: [Int!]
  value_not_in: [Int!]
  cost: Int
  cost_not: Int
  cost_gt: Int
  cost_lt: Int
  cost_gte: Int
  cost_lte: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  oldName: String
  oldName_not: String
  oldName_gt: String
  oldName_lt: String
  oldName_gte: String
  oldName_lte: String
  oldName_in: [String!]
  oldName_not_in: [String!]
  oldName_contains: String
  oldName_contains_nocase: String
  oldName_not_contains: String
  oldName_not_contains_nocase: String
  oldName_starts_with: String
  oldName_starts_with_nocase: String
  oldName_not_starts_with: String
  oldName_not_starts_with_nocase: String
  oldName_ends_with: String
  oldName_ends_with_nocase: String
  oldName_not_ends_with: String
  oldName_not_ends_with_nocase: String
  newName: String
  newName_not: String
  newName_gt: String
  newName_lt: String
  newName_gte: String
  newName_lte: String
  newName_in: [String!]
  newName_not_in: [String!]
  newName_contains: String
  newName_contains_nocase: String
  newName_not_contains: String
  newName_not_contains_nocase: String
  newName_starts_with: String
  newName_starts_with_nocase: String
  newName_not_starts_with: String
  newName_not_starts_with_nocase: String
  newName_ends_with: String
  newName_ends_with_nocase: String
  newName_not_ends_with: String
  newName_not_ends_with_nocase: String
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_BasicCraft_filter]
  or: [T_BasicCraft_filter]
}

enum T_BasicCraft_orderBy {
  id
  slot
  value
  cost
  oldName
  newName
  uri
}

type T_BasicPotion {
  id: ID!
  value: Int!
  cost: Int!
  type: String!
  name: String!
  uri: String!
  potionBalance(skip: Int = 0, first: Int = 100, orderBy: T_BasicPotionBalance_orderBy, orderDirection: T_OrderDirection, where: T_BasicPotionBalance_filter): [T_BasicPotionBalance!]!
}

type T_BasicPotionBalance {
  id: ID!
  balance: Int!
  potion: T_BasicPotion!
  player: T_Player!
}

input T_BasicPotionBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  balance: Int
  balance_not: Int
  balance_gt: Int
  balance_lt: Int
  balance_gte: Int
  balance_lte: Int
  balance_in: [Int!]
  balance_not_in: [Int!]
  potion: String
  potion_not: String
  potion_gt: String
  potion_lt: String
  potion_gte: String
  potion_lte: String
  potion_in: [String!]
  potion_not_in: [String!]
  potion_contains: String
  potion_contains_nocase: String
  potion_not_contains: String
  potion_not_contains_nocase: String
  potion_starts_with: String
  potion_starts_with_nocase: String
  potion_not_starts_with: String
  potion_not_starts_with_nocase: String
  potion_ends_with: String
  potion_ends_with_nocase: String
  potion_not_ends_with: String
  potion_not_ends_with_nocase: String
  potion_: T_BasicPotion_filter
  player: String
  player_not: String
  player_gt: String
  player_lt: String
  player_gte: String
  player_lte: String
  player_in: [String!]
  player_not_in: [String!]
  player_contains: String
  player_contains_nocase: String
  player_not_contains: String
  player_not_contains_nocase: String
  player_starts_with: String
  player_starts_with_nocase: String
  player_not_starts_with: String
  player_not_starts_with_nocase: String
  player_ends_with: String
  player_ends_with_nocase: String
  player_not_ends_with: String
  player_not_ends_with_nocase: String
  player_: T_Player_filter
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_BasicPotionBalance_filter]
  or: [T_BasicPotionBalance_filter]
}

enum T_BasicPotionBalance_orderBy {
  id
  balance
  potion
  potion__id
  potion__value
  potion__cost
  potion__type
  potion__name
  potion__uri
  player
  player__id
  player__Player_id
  player__name
  player__classes
  player__stats
  player__exp
  player__level
  player__strength
  player__magic
  player__agility
  player__defense
  player__currentHealth
  player__maxHealth
  player__currentMana
  player__maxMana
  player__totalWins
  player__totalLosses
}

input T_BasicPotion_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  value: Int
  value_not: Int
  value_gt: Int
  value_lt: Int
  value_gte: Int
  value_lte: Int
  value_in: [Int!]
  value_not_in: [Int!]
  cost: Int
  cost_not: Int
  cost_gt: Int
  cost_lt: Int
  cost_gte: Int
  cost_lte: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  type: String
  type_not: String
  type_gt: String
  type_lt: String
  type_gte: String
  type_lte: String
  type_in: [String!]
  type_not_in: [String!]
  type_contains: String
  type_contains_nocase: String
  type_not_contains: String
  type_not_contains_nocase: String
  type_starts_with: String
  type_starts_with_nocase: String
  type_not_starts_with: String
  type_not_starts_with_nocase: String
  type_ends_with: String
  type_ends_with_nocase: String
  type_not_ends_with: String
  type_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  potionBalance_: T_BasicPotionBalance_filter
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_BasicPotion_filter]
  or: [T_BasicPotion_filter]
}

enum T_BasicPotion_orderBy {
  id
  value
  cost
  type
  name
  uri
  potionBalance
}

scalar T_BigDecimal

scalar BigInt

input T_BlockChangedFilter {
  number_gte: Int!
}

input T_Block_height {
  hash: T_Bytes
  number: Int
  number_gte: Int
}

scalar T_Bytes

type T_EquipCount {
  id: ID!
  count: Int!
}

input T_EquipCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: Int
  count_not: Int
  count_gt: Int
  count_lt: Int
  count_gte: Int
  count_lte: Int
  count_in: [Int!]
  count_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_EquipCount_filter]
  or: [T_EquipCount_filter]
}

enum T_EquipCount_orderBy {
  id
  count
}

type T_Equipment {
  id: ID!
  slot: String!
  rank: Int!
  value: Int!
  stat: String!
  player: T_Player!
  name: String!
  uri: String!
  isEquipped: Boolean!
}

type T_EquipmentInStore {
  id: ID!
  slot: String!
  value: Int!
  stat: String!
  cost: Int!
  name: String!
  uri: String!
}

input T_EquipmentInStore_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  slot: String
  slot_not: String
  slot_gt: String
  slot_lt: String
  slot_gte: String
  slot_lte: String
  slot_in: [String!]
  slot_not_in: [String!]
  slot_contains: String
  slot_contains_nocase: String
  slot_not_contains: String
  slot_not_contains_nocase: String
  slot_starts_with: String
  slot_starts_with_nocase: String
  slot_not_starts_with: String
  slot_not_starts_with_nocase: String
  slot_ends_with: String
  slot_ends_with_nocase: String
  slot_not_ends_with: String
  slot_not_ends_with_nocase: String
  value: Int
  value_not: Int
  value_gt: Int
  value_lt: Int
  value_gte: Int
  value_lte: Int
  value_in: [Int!]
  value_not_in: [Int!]
  stat: String
  stat_not: String
  stat_gt: String
  stat_lt: String
  stat_gte: String
  stat_lte: String
  stat_in: [String!]
  stat_not_in: [String!]
  stat_contains: String
  stat_contains_nocase: String
  stat_not_contains: String
  stat_not_contains_nocase: String
  stat_starts_with: String
  stat_starts_with_nocase: String
  stat_not_starts_with: String
  stat_not_starts_with_nocase: String
  stat_ends_with: String
  stat_ends_with_nocase: String
  stat_not_ends_with: String
  stat_not_ends_with_nocase: String
  cost: Int
  cost_not: Int
  cost_gt: Int
  cost_lt: Int
  cost_gte: Int
  cost_lte: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_EquipmentInStore_filter]
  or: [T_EquipmentInStore_filter]
}

enum T_EquipmentInStore_orderBy {
  id
  slot
  value
  stat
  cost
  name
  uri
}

input T_Equipment_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  slot: String
  slot_not: String
  slot_gt: String
  slot_lt: String
  slot_gte: String
  slot_lte: String
  slot_in: [String!]
  slot_not_in: [String!]
  slot_contains: String
  slot_contains_nocase: String
  slot_not_contains: String
  slot_not_contains_nocase: String
  slot_starts_with: String
  slot_starts_with_nocase: String
  slot_not_starts_with: String
  slot_not_starts_with_nocase: String
  slot_ends_with: String
  slot_ends_with_nocase: String
  slot_not_ends_with: String
  slot_not_ends_with_nocase: String
  rank: Int
  rank_not: Int
  rank_gt: Int
  rank_lt: Int
  rank_gte: Int
  rank_lte: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  value: Int
  value_not: Int
  value_gt: Int
  value_lt: Int
  value_gte: Int
  value_lte: Int
  value_in: [Int!]
  value_not_in: [Int!]
  stat: String
  stat_not: String
  stat_gt: String
  stat_lt: String
  stat_gte: String
  stat_lte: String
  stat_in: [String!]
  stat_not_in: [String!]
  stat_contains: String
  stat_contains_nocase: String
  stat_not_contains: String
  stat_not_contains_nocase: String
  stat_starts_with: String
  stat_starts_with_nocase: String
  stat_not_starts_with: String
  stat_not_starts_with_nocase: String
  stat_ends_with: String
  stat_ends_with_nocase: String
  stat_not_ends_with: String
  stat_not_ends_with_nocase: String
  player: String
  player_not: String
  player_gt: String
  player_lt: String
  player_gte: String
  player_lte: String
  player_in: [String!]
  player_not_in: [String!]
  player_contains: String
  player_contains_nocase: String
  player_not_contains: String
  player_not_contains_nocase: String
  player_starts_with: String
  player_starts_with_nocase: String
  player_not_starts_with: String
  player_not_starts_with_nocase: String
  player_ends_with: String
  player_ends_with_nocase: String
  player_not_ends_with: String
  player_not_ends_with_nocase: String
  player_: T_Player_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  isEquipped: Boolean
  isEquipped_not: Boolean
  isEquipped_in: [Boolean!]
  isEquipped_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_Equipment_filter]
  or: [T_Equipment_filter]
}

enum T_Equipment_orderBy {
  id
  slot
  rank
  value
  stat
  player
  player__id
  player__Player_id
  player__name
  player__classes
  player__stats
  player__exp
  player__level
  player__strength
  player__magic
  player__agility
  player__defense
  player__currentHealth
  player__maxHealth
  player__currentMana
  player__maxMana
  player__totalWins
  player__totalLosses
  name
  uri
  isEquipped
}

type T_Listing {
  id: ID!
  price: BigInt!
  seller: String!
  timestamp: BigInt!
  player: T_Player!
}

input T_Listing_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  seller: String
  seller_not: String
  seller_gt: String
  seller_lt: String
  seller_gte: String
  seller_lte: String
  seller_in: [String!]
  seller_not_in: [String!]
  seller_contains: String
  seller_contains_nocase: String
  seller_not_contains: String
  seller_not_contains_nocase: String
  seller_starts_with: String
  seller_starts_with_nocase: String
  seller_not_starts_with: String
  seller_not_starts_with_nocase: String
  seller_ends_with: String
  seller_ends_with_nocase: String
  seller_not_ends_with: String
  seller_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  player: String
  player_not: String
  player_gt: String
  player_lt: String
  player_gte: String
  player_lte: String
  player_in: [String!]
  player_not_in: [String!]
  player_contains: String
  player_contains_nocase: String
  player_not_contains: String
  player_not_contains_nocase: String
  player_starts_with: String
  player_starts_with_nocase: String
  player_not_starts_with: String
  player_not_starts_with_nocase: String
  player_ends_with: String
  player_ends_with_nocase: String
  player_not_ends_with: String
  player_not_ends_with_nocase: String
  player_: T_Player_filter
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_Listing_filter]
  or: [T_Listing_filter]
}

enum T_Listing_orderBy {
  id
  price
  seller
  timestamp
  player
  player__id
  player__Player_id
  player__name
  player__classes
  player__stats
  player__exp
  player__level
  player__strength
  player__magic
  player__agility
  player__defense
  player__currentHealth
  player__maxHealth
  player__currentMana
  player__maxMana
  player__totalWins
  player__totalLosses
}

type T_MagicMonster {
  id: ID!
  xpReward: Int!
  damage: Int!
  hp: Int!
  cooldown: Int!
  cost: Int!
  name: String!
  uri: String!
}

input T_MagicMonster_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  xpReward: Int
  xpReward_not: Int
  xpReward_gt: Int
  xpReward_lt: Int
  xpReward_gte: Int
  xpReward_lte: Int
  xpReward_in: [Int!]
  xpReward_not_in: [Int!]
  damage: Int
  damage_not: Int
  damage_gt: Int
  damage_lt: Int
  damage_gte: Int
  damage_lte: Int
  damage_in: [Int!]
  damage_not_in: [Int!]
  hp: Int
  hp_not: Int
  hp_gt: Int
  hp_lt: Int
  hp_gte: Int
  hp_lte: Int
  hp_in: [Int!]
  hp_not_in: [Int!]
  cooldown: Int
  cooldown_not: Int
  cooldown_gt: Int
  cooldown_lt: Int
  cooldown_gte: Int
  cooldown_lte: Int
  cooldown_in: [Int!]
  cooldown_not_in: [Int!]
  cost: Int
  cost_not: Int
  cost_gt: Int
  cost_lt: Int
  cost_gte: Int
  cost_lte: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_MagicMonster_filter]
  or: [T_MagicMonster_filter]
}

enum T_MagicMonster_orderBy {
  id
  xpReward
  damage
  hp
  cooldown
  cost
  name
  uri
}

type T_Monster {
  id: ID!
  xpReward: Int!
  damage: Int!
  hp: Int!
  cooldown: Int!
  name: String!
  uri: String!
}

input T_Monster_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  xpReward: Int
  xpReward_not: Int
  xpReward_gt: Int
  xpReward_lt: Int
  xpReward_gte: Int
  xpReward_lte: Int
  xpReward_in: [Int!]
  xpReward_not_in: [Int!]
  damage: Int
  damage_not: Int
  damage_gt: Int
  damage_lt: Int
  damage_gte: Int
  damage_lte: Int
  damage_in: [Int!]
  damage_not_in: [Int!]
  hp: Int
  hp_not: Int
  hp_gt: Int
  hp_lt: Int
  hp_gte: Int
  hp_lte: Int
  hp_in: [Int!]
  hp_not_in: [Int!]
  cooldown: Int
  cooldown_not: Int
  cooldown_gt: Int
  cooldown_lt: Int
  cooldown_gte: Int
  cooldown_lte: Int
  cooldown_in: [Int!]
  cooldown_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_Monster_filter]
  or: [T_Monster_filter]
}

enum T_Monster_orderBy {
  id
  xpReward
  damage
  hp
  cooldown
  name
  uri
}

"""Defines the order direction, either ascending or descending"""
enum T_OrderDirection {
  asc
  desc
}

type T_Player {
  id: ID!
  Player_id: BigInt!
  user: T_User!
  name: String!
  classes: String!
  stats: String!
  exp: Int!
  level: Int!
  strength: Int!
  magic: Int!
  agility: Int!
  defense: Int!
  currentHealth: Int!
  maxHealth: Int!
  currentMana: Int!
  maxMana: Int!
  totalWins: Int!
  totalLosses: Int!
  potionBalance(skip: Int = 0, first: Int = 100, orderBy: T_BasicPotionBalance_orderBy, orderDirection: T_OrderDirection, where: T_BasicPotionBalance_filter): [T_BasicPotionBalance!]!
  equipment(skip: Int = 0, first: Int = 100, orderBy: T_Equipment_orderBy, orderDirection: T_OrderDirection, where: T_Equipment_filter): [T_Equipment!]!
  arenaResult(skip: Int = 0, first: Int = 100, orderBy: T_ArenaResults_orderBy, orderDirection: T_OrderDirection, where: T_ArenaResults_filter): [T_ArenaResults!]!
}

input T_Player_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  Player_id: BigInt
  Player_id_not: BigInt
  Player_id_gt: BigInt
  Player_id_lt: BigInt
  Player_id_gte: BigInt
  Player_id_lte: BigInt
  Player_id_in: [BigInt!]
  Player_id_not_in: [BigInt!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: T_User_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  classes: String
  classes_not: String
  classes_gt: String
  classes_lt: String
  classes_gte: String
  classes_lte: String
  classes_in: [String!]
  classes_not_in: [String!]
  classes_contains: String
  classes_contains_nocase: String
  classes_not_contains: String
  classes_not_contains_nocase: String
  classes_starts_with: String
  classes_starts_with_nocase: String
  classes_not_starts_with: String
  classes_not_starts_with_nocase: String
  classes_ends_with: String
  classes_ends_with_nocase: String
  classes_not_ends_with: String
  classes_not_ends_with_nocase: String
  stats: String
  stats_not: String
  stats_gt: String
  stats_lt: String
  stats_gte: String
  stats_lte: String
  stats_in: [String!]
  stats_not_in: [String!]
  stats_contains: String
  stats_contains_nocase: String
  stats_not_contains: String
  stats_not_contains_nocase: String
  stats_starts_with: String
  stats_starts_with_nocase: String
  stats_not_starts_with: String
  stats_not_starts_with_nocase: String
  stats_ends_with: String
  stats_ends_with_nocase: String
  stats_not_ends_with: String
  stats_not_ends_with_nocase: String
  exp: Int
  exp_not: Int
  exp_gt: Int
  exp_lt: Int
  exp_gte: Int
  exp_lte: Int
  exp_in: [Int!]
  exp_not_in: [Int!]
  level: Int
  level_not: Int
  level_gt: Int
  level_lt: Int
  level_gte: Int
  level_lte: Int
  level_in: [Int!]
  level_not_in: [Int!]
  strength: Int
  strength_not: Int
  strength_gt: Int
  strength_lt: Int
  strength_gte: Int
  strength_lte: Int
  strength_in: [Int!]
  strength_not_in: [Int!]
  magic: Int
  magic_not: Int
  magic_gt: Int
  magic_lt: Int
  magic_gte: Int
  magic_lte: Int
  magic_in: [Int!]
  magic_not_in: [Int!]
  agility: Int
  agility_not: Int
  agility_gt: Int
  agility_lt: Int
  agility_gte: Int
  agility_lte: Int
  agility_in: [Int!]
  agility_not_in: [Int!]
  defense: Int
  defense_not: Int
  defense_gt: Int
  defense_lt: Int
  defense_gte: Int
  defense_lte: Int
  defense_in: [Int!]
  defense_not_in: [Int!]
  currentHealth: Int
  currentHealth_not: Int
  currentHealth_gt: Int
  currentHealth_lt: Int
  currentHealth_gte: Int
  currentHealth_lte: Int
  currentHealth_in: [Int!]
  currentHealth_not_in: [Int!]
  maxHealth: Int
  maxHealth_not: Int
  maxHealth_gt: Int
  maxHealth_lt: Int
  maxHealth_gte: Int
  maxHealth_lte: Int
  maxHealth_in: [Int!]
  maxHealth_not_in: [Int!]
  currentMana: Int
  currentMana_not: Int
  currentMana_gt: Int
  currentMana_lt: Int
  currentMana_gte: Int
  currentMana_lte: Int
  currentMana_in: [Int!]
  currentMana_not_in: [Int!]
  maxMana: Int
  maxMana_not: Int
  maxMana_gt: Int
  maxMana_lt: Int
  maxMana_gte: Int
  maxMana_lte: Int
  maxMana_in: [Int!]
  maxMana_not_in: [Int!]
  totalWins: Int
  totalWins_not: Int
  totalWins_gt: Int
  totalWins_lt: Int
  totalWins_gte: Int
  totalWins_lte: Int
  totalWins_in: [Int!]
  totalWins_not_in: [Int!]
  totalLosses: Int
  totalLosses_not: Int
  totalLosses_gt: Int
  totalLosses_lt: Int
  totalLosses_gte: Int
  totalLosses_lte: Int
  totalLosses_in: [Int!]
  totalLosses_not_in: [Int!]
  potionBalance_: T_BasicPotionBalance_filter
  equipment_: T_Equipment_filter
  arenaResult_: T_ArenaResults_filter
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_Player_filter]
  or: [T_Player_filter]
}

enum T_Player_orderBy {
  id
  Player_id
  user
  user__id
  user__gold
  user__gem
  name
  classes
  stats
  exp
  level
  strength
  magic
  agility
  defense
  currentHealth
  maxHealth
  currentMana
  maxMana
  totalWins
  totalLosses
  potionBalance
  equipment
  arenaResult
}

type Query {
  T_user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_User
  T_users(
    skip: Int = 0
    first: Int = 100
    orderBy: T_User_orderBy
    orderDirection: T_OrderDirection
    where: T_User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_User!]!
  T_player(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Player
  T_players(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Player_orderBy
    orderDirection: T_OrderDirection
    where: T_Player_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Player!]!
  T_equipment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Equipment
  T_equipments(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Equipment_orderBy
    orderDirection: T_OrderDirection
    where: T_Equipment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Equipment!]!
  T_equipmentInStore(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_EquipmentInStore
  T_equipmentInStores(
    skip: Int = 0
    first: Int = 100
    orderBy: T_EquipmentInStore_orderBy
    orderDirection: T_OrderDirection
    where: T_EquipmentInStore_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_EquipmentInStore!]!
  T_basicCraft(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_BasicCraft
  T_basicCrafts(
    skip: Int = 0
    first: Int = 100
    orderBy: T_BasicCraft_orderBy
    orderDirection: T_OrderDirection
    where: T_BasicCraft_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_BasicCraft!]!
  T_equipCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_EquipCount
  T_equipCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: T_EquipCount_orderBy
    orderDirection: T_OrderDirection
    where: T_EquipCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_EquipCount!]!
  T_monster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Monster
  T_monsters(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Monster_orderBy
    orderDirection: T_OrderDirection
    where: T_Monster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Monster!]!
  T_magicMonster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_MagicMonster
  T_magicMonsters(
    skip: Int = 0
    first: Int = 100
    orderBy: T_MagicMonster_orderBy
    orderDirection: T_OrderDirection
    where: T_MagicMonster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_MagicMonster!]!
  T_basicPotion(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_BasicPotion
  T_basicPotions(
    skip: Int = 0
    first: Int = 100
    orderBy: T_BasicPotion_orderBy
    orderDirection: T_OrderDirection
    where: T_BasicPotion_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_BasicPotion!]!
  T_basicPotionBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_BasicPotionBalance
  T_basicPotionBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: T_BasicPotionBalance_orderBy
    orderDirection: T_OrderDirection
    where: T_BasicPotionBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_BasicPotionBalance!]!
  T_arena(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Arena
  T_arenas(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Arena_orderBy
    orderDirection: T_OrderDirection
    where: T_Arena_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Arena!]!
  T_arenaResults(
    skip: Int = 0
    first: Int = 100
    orderBy: T_ArenaResults_orderBy
    orderDirection: T_OrderDirection
    where: T_ArenaResults_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_ArenaResults!]!
  T_sale(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Sale
  T_sales(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Sale_orderBy
    orderDirection: T_OrderDirection
    where: T_Sale_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Sale!]!
  T_listing(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Listing
  T_listings(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Listing_orderBy
    orderDirection: T_OrderDirection
    where: T_Listing_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Listing!]!
  """Access to subgraph metadata"""
  T__meta(block: T_Block_height): T__Meta_
}

type T_Sale {
  id: ID!
  price: BigInt!
  player: T_Player!
  seller: String!
  buyer: String!
  timestamp: BigInt!
  txHash: String!
}

input T_Sale_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  player: String
  player_not: String
  player_gt: String
  player_lt: String
  player_gte: String
  player_lte: String
  player_in: [String!]
  player_not_in: [String!]
  player_contains: String
  player_contains_nocase: String
  player_not_contains: String
  player_not_contains_nocase: String
  player_starts_with: String
  player_starts_with_nocase: String
  player_not_starts_with: String
  player_not_starts_with_nocase: String
  player_ends_with: String
  player_ends_with_nocase: String
  player_not_ends_with: String
  player_not_ends_with_nocase: String
  player_: T_Player_filter
  seller: String
  seller_not: String
  seller_gt: String
  seller_lt: String
  seller_gte: String
  seller_lte: String
  seller_in: [String!]
  seller_not_in: [String!]
  seller_contains: String
  seller_contains_nocase: String
  seller_not_contains: String
  seller_not_contains_nocase: String
  seller_starts_with: String
  seller_starts_with_nocase: String
  seller_not_starts_with: String
  seller_not_starts_with_nocase: String
  seller_ends_with: String
  seller_ends_with_nocase: String
  seller_not_ends_with: String
  seller_not_ends_with_nocase: String
  buyer: String
  buyer_not: String
  buyer_gt: String
  buyer_lt: String
  buyer_gte: String
  buyer_lte: String
  buyer_in: [String!]
  buyer_not_in: [String!]
  buyer_contains: String
  buyer_contains_nocase: String
  buyer_not_contains: String
  buyer_not_contains_nocase: String
  buyer_starts_with: String
  buyer_starts_with_nocase: String
  buyer_not_starts_with: String
  buyer_not_starts_with_nocase: String
  buyer_ends_with: String
  buyer_ends_with_nocase: String
  buyer_not_ends_with: String
  buyer_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  txHash: String
  txHash_not: String
  txHash_gt: String
  txHash_lt: String
  txHash_gte: String
  txHash_lte: String
  txHash_in: [String!]
  txHash_not_in: [String!]
  txHash_contains: String
  txHash_contains_nocase: String
  txHash_not_contains: String
  txHash_not_contains_nocase: String
  txHash_starts_with: String
  txHash_starts_with_nocase: String
  txHash_not_starts_with: String
  txHash_not_starts_with_nocase: String
  txHash_ends_with: String
  txHash_ends_with_nocase: String
  txHash_not_ends_with: String
  txHash_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_Sale_filter]
  or: [T_Sale_filter]
}

enum T_Sale_orderBy {
  id
  price
  player
  player__id
  player__Player_id
  player__name
  player__classes
  player__stats
  player__exp
  player__level
  player__strength
  player__magic
  player__agility
  player__defense
  player__currentHealth
  player__maxHealth
  player__currentMana
  player__maxMana
  player__totalWins
  player__totalLosses
  seller
  buyer
  timestamp
  txHash
}

type Subscription {
  T_user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_User
  T_users(
    skip: Int = 0
    first: Int = 100
    orderBy: T_User_orderBy
    orderDirection: T_OrderDirection
    where: T_User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_User!]!
  T_player(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Player
  T_players(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Player_orderBy
    orderDirection: T_OrderDirection
    where: T_Player_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Player!]!
  T_equipment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Equipment
  T_equipments(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Equipment_orderBy
    orderDirection: T_OrderDirection
    where: T_Equipment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Equipment!]!
  T_equipmentInStore(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_EquipmentInStore
  T_equipmentInStores(
    skip: Int = 0
    first: Int = 100
    orderBy: T_EquipmentInStore_orderBy
    orderDirection: T_OrderDirection
    where: T_EquipmentInStore_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_EquipmentInStore!]!
  T_basicCraft(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_BasicCraft
  T_basicCrafts(
    skip: Int = 0
    first: Int = 100
    orderBy: T_BasicCraft_orderBy
    orderDirection: T_OrderDirection
    where: T_BasicCraft_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_BasicCraft!]!
  T_equipCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_EquipCount
  T_equipCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: T_EquipCount_orderBy
    orderDirection: T_OrderDirection
    where: T_EquipCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_EquipCount!]!
  T_monster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Monster
  T_monsters(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Monster_orderBy
    orderDirection: T_OrderDirection
    where: T_Monster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Monster!]!
  T_magicMonster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_MagicMonster
  T_magicMonsters(
    skip: Int = 0
    first: Int = 100
    orderBy: T_MagicMonster_orderBy
    orderDirection: T_OrderDirection
    where: T_MagicMonster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_MagicMonster!]!
  T_basicPotion(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_BasicPotion
  T_basicPotions(
    skip: Int = 0
    first: Int = 100
    orderBy: T_BasicPotion_orderBy
    orderDirection: T_OrderDirection
    where: T_BasicPotion_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_BasicPotion!]!
  T_basicPotionBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_BasicPotionBalance
  T_basicPotionBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: T_BasicPotionBalance_orderBy
    orderDirection: T_OrderDirection
    where: T_BasicPotionBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_BasicPotionBalance!]!
  T_arena(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Arena
  T_arenas(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Arena_orderBy
    orderDirection: T_OrderDirection
    where: T_Arena_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Arena!]!
  T_arenaResults(
    skip: Int = 0
    first: Int = 100
    orderBy: T_ArenaResults_orderBy
    orderDirection: T_OrderDirection
    where: T_ArenaResults_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_ArenaResults!]!
  T_sale(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Sale
  T_sales(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Sale_orderBy
    orderDirection: T_OrderDirection
    where: T_Sale_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Sale!]!
  T_listing(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): T_Listing
  T_listings(
    skip: Int = 0
    first: Int = 100
    orderBy: T_Listing_orderBy
    orderDirection: T_OrderDirection
    where: T_Listing_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: T_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [T_Listing!]!
  """Access to subgraph metadata"""
  T__meta(block: T_Block_height): T__Meta_
}

type T_User {
  id: ID!
  gold: Int!
  gem: Int!
  players(skip: Int = 0, first: Int = 100, orderBy: T_Player_orderBy, orderDirection: T_OrderDirection, where: T_Player_filter): [T_Player!]!
}

input T_User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  gold: Int
  gold_not: Int
  gold_gt: Int
  gold_lt: Int
  gold_gte: Int
  gold_lte: Int
  gold_in: [Int!]
  gold_not_in: [Int!]
  gem: Int
  gem_not: Int
  gem_gt: Int
  gem_lt: Int
  gem_gte: Int
  gem_lte: Int
  gem_in: [Int!]
  gem_not_in: [Int!]
  players_: T_Player_filter
  """Filter for the block changed event."""
  _change_block: T_BlockChangedFilter
  and: [T_User_filter]
  or: [T_User_filter]
}

enum T_User_orderBy {
  id
  gold
  gem
  players
}

type T__Block_ {
  """The hash of the block"""
  hash: T_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type T__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: T__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}